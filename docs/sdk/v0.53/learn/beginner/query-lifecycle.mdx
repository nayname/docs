---
title: Query Lifecycle
---

<Note>
**Synopsis**
This document describes the lifecycle of a query in a Cosmos SDK application, from the user interface to application stores and back. The query is referred to as `MyQuery`.
</Note>

<Note>
**Pre-requisite Readings**

* [Transaction Lifecycle](docs/sdk/v0.53/learn/beginner/tx-lifecycle)
</Note>

## Query Creation

A [**query**](/docs/sdk/v0.53//build/building-modules/messages-and-queries#queries) is a request for information made by end-users of applications through an interface and processed by a full-node. Users can query information about the network, the application itself, and application state directly from the application's stores or modules. Note that queries are different from [transactions](/docs/sdk/v0.53/advanced/transactions) (view the lifecycle [here](/docs/sdk/v0.53/tx-lifecycle)), particularly in that they do not require consensus to be processed (as they do not trigger state-transitions); they can be fully handled by one full-node.

For the purpose of explaining the query lifecycle, let's say the query, `MyQuery`, is requesting a list of delegations made by a certain delegator address in the application called `simapp`. As is to be expected, the [`staking`](/docs/sdk/v0.53//build/modules/staking/README) module handles this query. But first, there are a few ways `MyQuery` can be created by users.

### CLI

The main interface for an application is the command-line interface. Users connect to a full-node and run the CLI directly from their machines - the CLI interacts directly with the full-node. To create `MyQuery` from their terminal, users type the following command:

```bash
simd query staking delegations <delegatorAddress>
```

This query command was defined by the [`staking`](/docs/sdk/v0.53//build/modules/staking/README) module developer and added to the list of subcommands by the application developer when creating the CLI.

Note that the general format is as follows:

```bash
simd query [moduleName] [command] <arguments> --flag <flagArg>
```

To provide values such as `--node` (the full-node the CLI connects to), the user can use the [`app.toml`](/docs/sdk/v0.53//user/run-node/run-node#configuring-the-node-using-apptoml-and-configtoml) config file to set them or provide them as flags.

The CLI understands a specific set of commands, defined in a hierarchical structure by the application developer: from the [root command](/docs/sdk/v0.53/advanced/cli#root-command) (`simd`), the type of command (`Myquery`), the module that contains the command (`staking`), and command itself (`delegations`). Thus, the CLI knows exactly which module handles this command and directly passes the call there.

### gRPC

Another interface through which users can make queries is [gRPC](https://grpc.io) requests to a [gRPC server](/docs/sdk/v0.53/advanced/grpc_rest#grpc-server). The endpoints are defined as [Protocol Buffers](https://developers.google.com/protocol-buffers) service methods inside `.proto` files, written in Protobuf's own language-agnostic interface definition language (IDL). The Protobuf ecosystem developed tools for code-generation from `*.proto` files into various languages. These tools allow to build gRPC clients easily.

One such tool is [grpcurl](https://github.com/fullstorydev/grpcurl), and a gRPC request for `MyQuery` using this client looks like:

```bash
grpcurl \
    -plaintext                                           # We want results in plain test
    -import-path ./proto \                               # Import these .proto files
    -proto ./proto/cosmos/staking/v1beta1/query.proto \  # Look into this .proto file for the Query protobuf service
    -d '{"address":"$MY_DELEGATOR"}' \                   # Query arguments
    localhost:9090 \                                     # gRPC server endpoint
    cosmos.staking.v1beta1.Query/Delegations             # Fully-qualified service method name
```

### REST

Another interface through which users can make queries is through HTTP Requests to a [REST server](/docs/sdk/v0.53/advanced/grpc_rest#rest-server). The REST server is fully auto-generated from Protobuf services, using [gRPC-gateway](https://github.com/grpc-ecosystem/grpc-gateway).

An example HTTP request for `MyQuery` looks like:

```bash
GET http://localhost:1317/cosmos/staking/v1beta1/delegators/{delegatorAddr}/delegations
```

## How Queries are Handled by the CLI

The preceding examples show how an external user can interact with a node by querying its state. To understand in more detail the exact lifecycle of a query, let's dig into how the CLI prepares the query, and how the node handles it. The interactions from the users' perspective are a bit different, but the underlying functions are almost identical because they are implementations of the same command defined by the module developer. This step of processing happens within the CLI, gRPC, or REST server, and heavily involves a `client.Context`.

### Context

The first thing that is created in the execution of a CLI command is a `client.Context`. A `client.Context` is an object that stores all the data needed to process a request on the user side. In particular, a `client.Context` stores the following:

* **Codec**: The [encoder/decoder](/docs/sdk/v0.53/advanced/encoding) used by the application, used to marshal the parameters and query before making the CometBFT RPC request and unmarshal the returned response into a JSON object. The default codec used by the CLI is Protobuf.
* **Account Decoder**: The account decoder from the [`auth`](/docs/sdk/v0.53//build/modules/auth/README) module, which translates `[]byte`s into accounts.
* **RPC Client**: The CometBFT RPC Client, or node, to which requests are relayed.
* **Keyring**: A \[Key Manager]../beginner/03-accounts.md#keyring) used to sign transactions and handle other operations with keys.
* **Output Writer**: A [Writer](https://pkg.go.dev/io/#Writer) used to output the response.
* **Configurations**: The flags configured by the user for this command, including `--height`, specifying the height of the blockchain to query, and `--indent`, which indicates to add an indent to the JSON response.

The `client.Context` also contains various functions such as `Query()`, which retrieves the RPC Client and makes an ABCI call to relay a query to a full-node.

```go expandable
package client

import (
    
	"bufio"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "os"
    "path"
    "strings"
    "github.com/cosmos/gogoproto/proto"
    "github.com/spf13/viper"
    "google.golang.org/grpc"
    "sigs.k8s.io/yaml"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/crypto/keyring"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

// PreprocessTxFn defines a hook by which chains can preprocess transactions before broadcasting
type PreprocessTxFn func(chainID string, key keyring.KeyType, tx TxBuilder)

error

// Context implements a typical context created in SDK modules for transaction
// handling and queries.
type Context struct {
    FromAddress           sdk.AccAddress
	Client                CometRPC
	GRPCClient            *grpc.ClientConn
	ChainID               string
	Codec                 codec.Codec
	InterfaceRegistry     codectypes.InterfaceRegistry
	Input                 io.Reader
	Keyring               keyring.Keyring
	KeyringOptions        []keyring.Option
	KeyringDir            string
	KeyringDefaultKeyName string
	Output                io.Writer
	OutputFormat          string
	Height                int64
	HomeDir               string
	From                  string
	BroadcastMode         string
	FromName              string
	SignModeStr           string
	UseLedger             bool
	Simulate              bool
	GenerateOnly          bool
	Offline               bool
	SkipConfirm           bool
	TxConfig              TxConfig
	AccountRetriever      AccountRetriever
	NodeURI               string
	FeePayer              sdk.AccAddress
	FeeGranter            sdk.AccAddress
	Viper                 *viper.Viper
	LedgerHasProtobuf     bool
	PreprocessTxHook      PreprocessTxFn

	// IsAux is true when the signer is an auxiliary signer (e.g. the tipper).
	IsAux bool

	// TODO: Deprecated (remove).
	LegacyAmino *codec.LegacyAmino

	// CmdContext is the context.Context from the Cobra command.
	CmdContext context.Context
}

// WithCmdContext returns a copy of the context with an updated context.Context,
// usually set to the cobra cmd context.
func (ctx Context)

WithCmdContext(c context.Context)

Context {
    ctx.CmdContext = c
	return ctx
}

// WithKeyring returns a copy of the context with an updated keyring.
func (ctx Context)

WithKeyring(k keyring.Keyring)

Context {
    ctx.Keyring = k
	return ctx
}

// WithKeyringOptions returns a copy of the context with an updated keyring.
func (ctx Context)

WithKeyringOptions(opts ...keyring.Option)

Context {
    ctx.KeyringOptions = opts
	return ctx
}

// WithInput returns a copy of the context with an updated input.
func (ctx Context)

WithInput(r io.Reader)

Context {
	// convert to a bufio.Reader to have a shared buffer between the keyring and the
	// the Commands, ensuring a read from one advance the read pointer for the other.
	// see https://github.com/cosmos/cosmos-sdk/issues/9566.
	ctx.Input = bufio.NewReader(r)

return ctx
}

// WithCodec returns a copy of the Context with an updated Codec.
func (ctx Context)

WithCodec(m codec.Codec)

Context {
    ctx.Codec = m
	return ctx
}

// WithLegacyAmino returns a copy of the context with an updated LegacyAmino codec.
// TODO: Deprecated (remove).
func (ctx Context)

WithLegacyAmino(cdc *codec.LegacyAmino)

Context {
    ctx.LegacyAmino = cdc
	return ctx
}

// WithOutput returns a copy of the context with an updated output writer (e.g. stdout).
func (ctx Context)

WithOutput(w io.Writer)

Context {
    ctx.Output = w
	return ctx
}

// WithFrom returns a copy of the context with an updated from address or name.
func (ctx Context)

WithFrom(from string)

Context {
    ctx.From = from
	return ctx
}

// WithOutputFormat returns a copy of the context with an updated OutputFormat field.
func (ctx Context)

WithOutputFormat(format string)

Context {
    ctx.OutputFormat = format
	return ctx
}

// WithNodeURI returns a copy of the context with an updated node URI.
func (ctx Context)

WithNodeURI(nodeURI string)

Context {
    ctx.NodeURI = nodeURI
	return ctx
}

// WithHeight returns a copy of the context with an updated height.
func (ctx Context)

WithHeight(height int64)

Context {
    ctx.Height = height
	return ctx
}

// WithClient returns a copy of the context with an updated RPC client
// instance.
func (ctx Context)

WithClient(client CometRPC)

Context {
    ctx.Client = client
	return ctx
}

// WithGRPCClient returns a copy of the context with an updated GRPC client
// instance.
func (ctx Context)

WithGRPCClient(grpcClient *grpc.ClientConn)

Context {
    ctx.GRPCClient = grpcClient
	return ctx
}

// WithUseLedger returns a copy of the context with an updated UseLedger flag.
func (ctx Context)

WithUseLedger(useLedger bool)

Context {
    ctx.UseLedger = useLedger
	return ctx
}

// WithChainID returns a copy of the context with an updated chain ID.
func (ctx Context)

WithChainID(chainID string)

Context {
    ctx.ChainID = chainID
	return ctx
}

// WithHomeDir returns a copy of the Context with HomeDir set.
func (ctx Context)

WithHomeDir(dir string)

Context {
    if dir != "" {
    ctx.HomeDir = dir
}

return ctx
}

// WithKeyringDir returns a copy of the Context with KeyringDir set.
func (ctx Context)

WithKeyringDir(dir string)

Context {
    ctx.KeyringDir = dir
	return ctx
}

// WithKeyringDefaultKeyName returns a copy of the Context with KeyringDefaultKeyName set.
func (ctx Context)

WithKeyringDefaultKeyName(keyName string)

Context {
    ctx.KeyringDefaultKeyName = keyName
	return ctx
}

// WithGenerateOnly returns a copy of the context with updated GenerateOnly value
func (ctx Context)

WithGenerateOnly(generateOnly bool)

Context {
    ctx.GenerateOnly = generateOnly
	return ctx
}

// WithSimulation returns a copy of the context with updated Simulate value
func (ctx Context)

WithSimulation(simulate bool)

Context {
    ctx.Simulate = simulate
	return ctx
}

// WithOffline returns a copy of the context with updated Offline value.
func (ctx Context)

WithOffline(offline bool)

Context {
    ctx.Offline = offline
	return ctx
}

// WithFromName returns a copy of the context with an updated from account name.
func (ctx Context)

WithFromName(name string)

Context {
    ctx.FromName = name
	return ctx
}

// WithFromAddress returns a copy of the context with an updated from account
// address.
func (ctx Context)

WithFromAddress(addr sdk.AccAddress)

Context {
    ctx.FromAddress = addr
	return ctx
}

// WithFeePayerAddress returns a copy of the context with an updated fee payer account
// address.
func (ctx Context)

WithFeePayerAddress(addr sdk.AccAddress)

Context {
    ctx.FeePayer = addr
	return ctx
}

// WithFeeGranterAddress returns a copy of the context with an updated fee granter account
// address.
func (ctx Context)

WithFeeGranterAddress(addr sdk.AccAddress)

Context {
    ctx.FeeGranter = addr
	return ctx
}

// WithBroadcastMode returns a copy of the context with an updated broadcast
// mode.
func (ctx Context)

WithBroadcastMode(mode string)

Context {
    ctx.BroadcastMode = mode
	return ctx
}

// WithSignModeStr returns a copy of the context with an updated SignMode
// value.
func (ctx Context)

WithSignModeStr(signModeStr string)

Context {
    ctx.SignModeStr = signModeStr
	return ctx
}

// WithSkipConfirmation returns a copy of the context with an updated SkipConfirm
// value.
func (ctx Context)

WithSkipConfirmation(skip bool)

Context {
    ctx.SkipConfirm = skip
	return ctx
}

// WithTxConfig returns the context with an updated TxConfig
func (ctx Context)

WithTxConfig(generator TxConfig)

Context {
    ctx.TxConfig = generator
	return ctx
}

// WithAccountRetriever returns the context with an updated AccountRetriever
func (ctx Context)

WithAccountRetriever(retriever AccountRetriever)

Context {
    ctx.AccountRetriever = retriever
	return ctx
}

// WithInterfaceRegistry returns the context with an updated InterfaceRegistry
func (ctx Context)

WithInterfaceRegistry(interfaceRegistry codectypes.InterfaceRegistry)

Context {
    ctx.InterfaceRegistry = interfaceRegistry
	return ctx
}

// WithViper returns the context with Viper field. This Viper instance is used to read
// client-side config from the config file.
func (ctx Context)

WithViper(prefix string)

Context {
    v := viper.New()
    if prefix == "" {
    executableName, _ := os.Executable()

prefix = path.Base(executableName)
}

v.SetEnvPrefix(prefix)

v.SetEnvKeyReplacer(strings.NewReplacer(".", "_", "-", "_"))

v.AutomaticEnv()

ctx.Viper = v
	return ctx
}

// WithAux returns a copy of the context with an updated IsAux value.
func (ctx Context)

WithAux(isAux bool)

Context {
    ctx.IsAux = isAux
	return ctx
}

// WithLedgerHasProto returns the context with the provided boolean value, indicating
// whether the target Ledger application can support Protobuf payloads.
func (ctx Context)

WithLedgerHasProtobuf(val bool)

Context {
    ctx.LedgerHasProtobuf = val
	return ctx
}

// WithPreprocessTxHook returns the context with the provided preprocessing hook, which
// enables chains to preprocess the transaction using the builder.
func (ctx Context)

WithPreprocessTxHook(preprocessFn PreprocessTxFn)

Context {
    ctx.PreprocessTxHook = preprocessFn
	return ctx
}

// PrintString prints the raw string to ctx.Output if it's defined, otherwise to os.Stdout
func (ctx Context)

PrintString(str string)

error {
    return ctx.PrintBytes([]byte(str))
}

// PrintBytes prints the raw bytes to ctx.Output if it's defined, otherwise to os.Stdout.
// NOTE: for printing a complex state object, you should use ctx.PrintOutput
func (ctx Context)

PrintBytes(o []byte)

error {
    writer := ctx.Output
    if writer == nil {
    writer = os.Stdout
}

	_, err := writer.Write(o)

return err
}

// PrintProto outputs toPrint to the ctx.Output based on ctx.OutputFormat which is
// either text or json. If text, toPrint will be YAML encoded. Otherwise, toPrint
// will be JSON encoded using ctx.Codec. An error is returned upon failure.
func (ctx Context)

PrintProto(toPrint proto.Message)

error {
	// always serialize JSON initially because proto json can't be directly YAML encoded
	out, err := ctx.Codec.MarshalJSON(toPrint)
    if err != nil {
    return err
}

return ctx.printOutput(out)
}

// PrintObjectLegacy is a variant of PrintProto that doesn't require a proto.Message type
// and uses amino JSON encoding.
// Deprecated: It will be removed in the near future!
func (ctx Context)

PrintObjectLegacy(toPrint any)

error {
    out, err := ctx.LegacyAmino.MarshalJSON(toPrint)
    if err != nil {
    return err
}

return ctx.printOutput(out)
}

// PrintRaw is a variant of PrintProto that doesn't require a proto.Message type
// and uses a raw JSON message. No marshaling is performed.
func (ctx Context)

PrintRaw(toPrint json.RawMessage)

error {
    return ctx.printOutput(toPrint)
}

func (ctx Context)

printOutput(out []byte)

error {
    var err error
    if ctx.OutputFormat == "text" {
    out, err = yaml.JSONToYAML(out)
    if err != nil {
    return err
}
	
}
    writer := ctx.Output
    if writer == nil {
    writer = os.Stdout
}

	_, err = writer.Write(out)
    if err != nil {
    return err
}
    if ctx.OutputFormat != "text" {
		// append new-line for formats besides YAML
		_, err = writer.Write([]byte("\n"))
    if err != nil {
    return err
}
	
}

return nil
}

// GetFromFields returns a from account address, account name and keyring type, given either an address or key name.
// If clientCtx.Simulate is true the keystore is not accessed and a valid address must be provided
// If clientCtx.GenerateOnly is true the keystore is only accessed if a key name is provided
// If from is empty, the default key if specified in the context will be used
func GetFromFields(clientCtx Context, kr keyring.Keyring, from string) (sdk.AccAddress, string, keyring.KeyType, error) {
    if from == "" && clientCtx.KeyringDefaultKeyName != "" {
    from = clientCtx.KeyringDefaultKeyName
		_ = clientCtx.PrintString(fmt.Sprintf("No key name or address provided; using the default key: %s\n", clientCtx.KeyringDefaultKeyName))
}
    if from == "" {
    return nil, "", 0, nil
}

addr, err := sdk.AccAddressFromBech32(from)
    switch {
    case clientCtx.Simulate:
    if err != nil {
    return nil, "", 0, fmt.Errorf("a valid bech32 address must be provided in simulation mode: %w", err)
}

return addr, "", 0, nil
    case clientCtx.GenerateOnly:
    if err == nil {
    return addr, "", 0, nil
}
	
}

var k *keyring.Record
    if err == nil {
    k, err = kr.KeyByAddress(addr)
    if err != nil {
    return nil, "", 0, err
}
	
}

else {
    k, err = kr.Key(from)
    if err != nil {
    return nil, "", 0, err
}
	
}

addr, err = k.GetAddress()
    if err != nil {
    return nil, "", 0, err
}

return addr, k.Name, k.GetType(), nil
}

// NewKeyringFromBackend gets a Keyring object from a backend
func NewKeyringFromBackend(ctx Context, backend string) (keyring.Keyring, error) {
    if ctx.Simulate {
    backend = keyring.BackendMemory
}

return keyring.New(sdk.KeyringServiceName(), backend, ctx.KeyringDir, ctx.Input, ctx.Codec, ctx.KeyringOptions...)
}
```

The `client.Context`'s primary role is to store data used during interactions with the end-user and provide methods to interact with this data - it is used before and after the query is processed by the full-node. Specifically, in handling `MyQuery`, the `client.Context` is utilized to encode the query parameters, retrieve the full-node, and write the output. Prior to being relayed to a full-node, the query needs to be encoded into a `[]byte` form, as full-nodes are application-agnostic and do not understand specific types. The full-node (RPC Client) itself is retrieved using the `client.Context`, which knows which node the user CLI is connected to. The query is relayed to this full-node to be processed. Finally, the `client.Context` contains a `Writer` to write output when the response is returned. These steps are further described in later sections.

### Arguments and Route Creation

At this point in the lifecycle, the user has created a CLI command with all of the data they wish to include in their query. A `client.Context` exists to assist in the rest of the `MyQuery`'s journey. Now, the next step is to parse the command or request, extract the arguments, and encode everything. These steps all happen on the user side within the interface they are interacting with.

#### Encoding

In our case (querying an address's delegations), `MyQuery` contains an [address](/docs/sdk/v0.53/accounts#addresses) `delegatorAddress` as its only argument. However, the request can only contain `[]byte`s, as it is ultimately relayed to a consensus engine (e.g. CometBFT) of a full-node that has no inherent knowledge of the application types. Thus, the `codec` of `client.Context` is used to marshal the address.

Here is what the code looks like for the CLI command:

```go
// Reference: https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/x/staking/client/cli/query.go#L315-L318
```

#### gRPC Query Client Creation

The Cosmos SDK leverages code generated from Protobuf services to make queries. The `staking` module's `MyQuery` service generates a `queryClient`, which the CLI uses to make queries. Here is the relevant code:

```go
// Reference: https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/x/staking/client/cli/query.go#L308-L343
```

Under the hood, the `client.Context` has a `Query()` function used to retrieve the pre-configured node and relay a query to it; the function takes the query fully-qualified service method name as path (in our case: `/cosmos.staking.v1beta1.Query/Delegations`), and arguments as parameters. It first retrieves the RPC Client (called the [**node**](/docs/sdk/v0.53/advanced/node)) configured by the user to relay this query to, and creates the `ABCIQueryOptions` (parameters formatted for the ABCI call). The node is then used to make the ABCI call, `ABCIQueryWithOptions()`.

Here is what the code looks like:

```go expandable
package client

import (
    
	"context"
    "fmt"
    "strings"
    "github.com/cockroachdb/errors"
	abci "github.com/cometbft/cometbft/abci/types"
	rpcclient "github.com/cometbft/cometbft/rpc/client"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "cosmossdk.io/store/rootmulti"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

// GetNode returns an RPC client. If the context's client is not defined, an
// error is returned.
func (ctx Context)

GetNode() (CometRPC, error) {
    if ctx.Client == nil {
    return nil, errors.New("no RPC client is defined in offline mode")
}

return ctx.Client, nil
}

// Query performs a query to a CometBFT node with the provided path.
// It returns the result and height of the query upon success or an error if
// the query fails.
func (ctx Context)

Query(path string) ([]byte, int64, error) {
    return ctx.query(path, nil)
}

// QueryWithData performs a query to a CometBFT node with the provided path
// and a data payload. It returns the result and height of the query upon success
// or an error if the query fails.
func (ctx Context)

QueryWithData(path string, data []byte) ([]byte, int64, error) {
    return ctx.query(path, data)
}

// QueryStore performs a query to a CometBFT node with the provided key and
// store name. It returns the result and height of the query upon success
// or an error if the query fails.
func (ctx Context)

QueryStore(key []byte, storeName string) ([]byte, int64, error) {
    return ctx.queryStore(key, storeName, "key")
}

// QueryABCI performs a query to a CometBFT node with the provide RequestQuery.
// It returns the ResultQuery obtained from the query. The height used to perform
// the query is the RequestQuery Height if it is non-zero, otherwise the context
// height is used.
func (ctx Context)

QueryABCI(req abci.RequestQuery) (abci.ResponseQuery, error) {
    return ctx.queryABCI(req)
}

// GetFromAddress returns the from address from the context's name.
func (ctx Context)

GetFromAddress()

sdk.AccAddress {
    return ctx.FromAddress
}

// GetFeePayerAddress returns the fee granter address from the context
func (ctx Context)

GetFeePayerAddress()

sdk.AccAddress {
    return ctx.FeePayer
}

// GetFeeGranterAddress returns the fee granter address from the context
func (ctx Context)

GetFeeGranterAddress()

sdk.AccAddress {
    return ctx.FeeGranter
}

// GetFromName returns the key name for the current context.
func (ctx Context)

GetFromName()

string {
    return ctx.FromName
}

func (ctx Context)

queryABCI(req abci.RequestQuery) (abci.ResponseQuery, error) {
    node, err := ctx.GetNode()
    if err != nil {
    return abci.ResponseQuery{
}, err
}

var queryHeight int64
    if req.Height != 0 {
    queryHeight = req.Height
}

else {
		// fallback on the context height
		queryHeight = ctx.Height
}
    opts := rpcclient.ABCIQueryOptions{
    Height: queryHeight,
    Prove:  req.Prove,
}

result, err := node.ABCIQueryWithOptions(context.Background(), req.Path, req.Data, opts)
    if err != nil {
    return abci.ResponseQuery{
}, err
}
    if !result.Response.IsOK() {
    return abci.ResponseQuery{
}, sdkErrorToGRPCError(result.Response)
}

	// data from trusted node or subspace query doesn't need verification
    if !opts.Prove || !isQueryStoreWithProof(req.Path) {
    return result.Response, nil
}

return result.Response, nil
}

func sdkErrorToGRPCError(resp abci.ResponseQuery)

error {
    switch resp.Code {
    case sdkerrors.ErrInvalidRequest.ABCICode():
		return status.Error(codes.InvalidArgument, resp.Log)
    case sdkerrors.ErrUnauthorized.ABCICode():
		return status.Error(codes.Unauthenticated, resp.Log)
    case sdkerrors.ErrKeyNotFound.ABCICode():
		return status.Error(codes.NotFound, resp.Log)

default:
		return status.Error(codes.Unknown, resp.Log)
}
}

// query performs a query to a CometBFT node with the provided store name
// and path. It returns the result and height of the query upon success
// or an error if the query fails.
func (ctx Context)

query(path string, key []byte) ([]byte, int64, error) {
    resp, err := ctx.queryABCI(abci.RequestQuery{
    Path:   path,
    Data:   key,
    Height: ctx.Height,
})
    if err != nil {
    return nil, 0, err
}

return resp.Value, resp.Height, nil
}

// queryStore performs a query to a CometBFT node with the provided a store
// name and path. It returns the result and height of the query upon success
// or an error if the query fails.
func (ctx Context)

queryStore(key []byte, storeName, endPath string) ([]byte, int64, error) {
    path := fmt.Sprintf("/store/%s/%s", storeName, endPath)

return ctx.query(path, key)
}

// isQueryStoreWithProof expects a format like /<queryType>/<storeName>/<subpath>
// queryType must be "store" and subpath must be "key" to require a proof.
func isQueryStoreWithProof(path string)

bool {
    if !strings.HasPrefix(path, "/") {
    return false
}
    paths := strings.SplitN(path[1:], "/", 3)
    switch {
    case len(paths) != 3:
		return false
    case paths[0] != "store":
		return false
    case rootmulti.RequireProof("/" + paths[2]):
		return true
}

return false
}
```

## RPC

With a call to `ABCIQueryWithOptions()`, `MyQuery` is received by a [full-node](/docs/sdk/v0.53/advanced/encoding) which then processes the request. Note that, while the RPC is made to the consensus engine (e.g. CometBFT) of a full-node, queries are not part of consensus and so are not broadcasted to the rest of the network, as they do not require anything the network needs to agree upon.

Read more about ABCI Clients and CometBFT RPC in the [CometBFT documentation](https://docs.cometbft.com/v0.37/spec/rpc/).

## Application Query Handling

When a query is received by the full-node after it has been relayed from the underlying consensus engine, it is at that point being handled within an environment that understands application-specific types and has a copy of the state. [`baseapp`](/docs/sdk/v0.53/advanced/baseapp) implements the ABCI [`Query()`](/docs/sdk/v0.53/advanced/baseapp#query) function and handles gRPC queries. The query route is parsed, and it matches the fully-qualified service method name of an existing service method (most likely in one of the modules), then `baseapp` relays the request to the relevant module.

Since `MyQuery` has a Protobuf fully-qualified service method name from the `staking` module (recall `/cosmos.staking.v1beta1.Query/Delegations`), `baseapp` first parses the path, then uses its own internal `GRPCQueryRouter` to retrieve the corresponding gRPC handler, and routes the query to the module. The gRPC handler is responsible for recognizing this query, retrieving the appropriate values from the application's stores, and returning a response. Read more about query services [here](/docs/sdk/v0.53//build/building-modules/query-services).

Once a result is received from the querier, `baseapp` begins the process of returning a response to the user.

## Response

Since `Query()` is an ABCI function, `baseapp` returns the response as an [`abci.ResponseQuery`](https://docs.cometbft.com/master/spec/abci/abci.html#query-2) type. The `client.Context` `Query()` routine receives the response and.

### CLI Response

The application [`codec`](/docs/sdk/v0.53/advanced/encoding) is used to unmarshal the response to a JSON and the `client.Context` prints the output to the command line, applying any configurations such as the output type (text, JSON or YAML).

```go expandable
package client

import (
    
	"bufio"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "os"
    "path"
    "strings"
    "github.com/cosmos/gogoproto/proto"
    "github.com/spf13/viper"
    "google.golang.org/grpc"
    "sigs.k8s.io/yaml"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/crypto/keyring"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

// PreprocessTxFn defines a hook by which chains can preprocess transactions before broadcasting
type PreprocessTxFn func(chainID string, key keyring.KeyType, tx TxBuilder)

error

// Context implements a typical context created in SDK modules for transaction
// handling and queries.
type Context struct {
    FromAddress           sdk.AccAddress
	Client                CometRPC
	GRPCClient            *grpc.ClientConn
	ChainID               string
	Codec                 codec.Codec
	InterfaceRegistry     codectypes.InterfaceRegistry
	Input                 io.Reader
	Keyring               keyring.Keyring
	KeyringOptions        []keyring.Option
	KeyringDir            string
	KeyringDefaultKeyName string
	Output                io.Writer
	OutputFormat          string
	Height                int64
	HomeDir               string
	From                  string
	BroadcastMode         string
	FromName              string
	SignModeStr           string
	UseLedger             bool
	Simulate              bool
	GenerateOnly          bool
	Offline               bool
	SkipConfirm           bool
	TxConfig              TxConfig
	AccountRetriever      AccountRetriever
	NodeURI               string
	FeePayer              sdk.AccAddress
	FeeGranter            sdk.AccAddress
	Viper                 *viper.Viper
	LedgerHasProtobuf     bool
	PreprocessTxHook      PreprocessTxFn

	// IsAux is true when the signer is an auxiliary signer (e.g. the tipper).
	IsAux bool

	// TODO: Deprecated (remove).
	LegacyAmino *codec.LegacyAmino

	// CmdContext is the context.Context from the Cobra command.
	CmdContext context.Context
}

// WithCmdContext returns a copy of the context with an updated context.Context,
// usually set to the cobra cmd context.
func (ctx Context)

WithCmdContext(c context.Context)

Context {
    ctx.CmdContext = c
	return ctx
}

// WithKeyring returns a copy of the context with an updated keyring.
func (ctx Context)

WithKeyring(k keyring.Keyring)

Context {
    ctx.Keyring = k
	return ctx
}

// WithKeyringOptions returns a copy of the context with an updated keyring.
func (ctx Context)

WithKeyringOptions(opts ...keyring.Option)

Context {
    ctx.KeyringOptions = opts
	return ctx
}

// WithInput returns a copy of the context with an updated input.
func (ctx Context)

WithInput(r io.Reader)

Context {
	// convert to a bufio.Reader to have a shared buffer between the keyring and the
	// the Commands, ensuring a read from one advance the read pointer for the other.
	// see https://github.com/cosmos/cosmos-sdk/issues/9566.
	ctx.Input = bufio.NewReader(r)

return ctx
}

// WithCodec returns a copy of the Context with an updated Codec.
func (ctx Context)

WithCodec(m codec.Codec)

Context {
    ctx.Codec = m
	return ctx
}

// WithLegacyAmino returns a copy of the context with an updated LegacyAmino codec.
// TODO: Deprecated (remove).
func (ctx Context)

WithLegacyAmino(cdc *codec.LegacyAmino)

Context {
    ctx.LegacyAmino = cdc
	return ctx
}

// WithOutput returns a copy of the context with an updated output writer (e.g. stdout).
func (ctx Context)

WithOutput(w io.Writer)

Context {
    ctx.Output = w
	return ctx
}

// WithFrom returns a copy of the context with an updated from address or name.
func (ctx Context)

WithFrom(from string)

Context {
    ctx.From = from
	return ctx
}

// WithOutputFormat returns a copy of the context with an updated OutputFormat field.
func (ctx Context)

WithOutputFormat(format string)

Context {
    ctx.OutputFormat = format
	return ctx
}

// WithNodeURI returns a copy of the context with an updated node URI.
func (ctx Context)

WithNodeURI(nodeURI string)

Context {
    ctx.NodeURI = nodeURI
	return ctx
}

// WithHeight returns a copy of the context with an updated height.
func (ctx Context)

WithHeight(height int64)

Context {
    ctx.Height = height
	return ctx
}

// WithClient returns a copy of the context with an updated RPC client
// instance.
func (ctx Context)

WithClient(client CometRPC)

Context {
    ctx.Client = client
	return ctx
}

// WithGRPCClient returns a copy of the context with an updated GRPC client
// instance.
func (ctx Context)

WithGRPCClient(grpcClient *grpc.ClientConn)

Context {
    ctx.GRPCClient = grpcClient
	return ctx
}

// WithUseLedger returns a copy of the context with an updated UseLedger flag.
func (ctx Context)

WithUseLedger(useLedger bool)

Context {
    ctx.UseLedger = useLedger
	return ctx
}

// WithChainID returns a copy of the context with an updated chain ID.
func (ctx Context)

WithChainID(chainID string)

Context {
    ctx.ChainID = chainID
	return ctx
}

// WithHomeDir returns a copy of the Context with HomeDir set.
func (ctx Context)

WithHomeDir(dir string)

Context {
    if dir != "" {
    ctx.HomeDir = dir
}

return ctx
}

// WithKeyringDir returns a copy of the Context with KeyringDir set.
func (ctx Context)

WithKeyringDir(dir string)

Context {
    ctx.KeyringDir = dir
	return ctx
}

// WithKeyringDefaultKeyName returns a copy of the Context with KeyringDefaultKeyName set.
func (ctx Context)

WithKeyringDefaultKeyName(keyName string)

Context {
    ctx.KeyringDefaultKeyName = keyName
	return ctx
}

// WithGenerateOnly returns a copy of the context with updated GenerateOnly value
func (ctx Context)

WithGenerateOnly(generateOnly bool)

Context {
    ctx.GenerateOnly = generateOnly
	return ctx
}

// WithSimulation returns a copy of the context with updated Simulate value
func (ctx Context)

WithSimulation(simulate bool)

Context {
    ctx.Simulate = simulate
	return ctx
}

// WithOffline returns a copy of the context with updated Offline value.
func (ctx Context)

WithOffline(offline bool)

Context {
    ctx.Offline = offline
	return ctx
}

// WithFromName returns a copy of the context with an updated from account name.
func (ctx Context)

WithFromName(name string)

Context {
    ctx.FromName = name
	return ctx
}

// WithFromAddress returns a copy of the context with an updated from account
// address.
func (ctx Context)

WithFromAddress(addr sdk.AccAddress)

Context {
    ctx.FromAddress = addr
	return ctx
}

// WithFeePayerAddress returns a copy of the context with an updated fee payer account
// address.
func (ctx Context)

WithFeePayerAddress(addr sdk.AccAddress)

Context {
    ctx.FeePayer = addr
	return ctx
}

// WithFeeGranterAddress returns a copy of the context with an updated fee granter account
// address.
func (ctx Context)

WithFeeGranterAddress(addr sdk.AccAddress)

Context {
    ctx.FeeGranter = addr
	return ctx
}

// WithBroadcastMode returns a copy of the context with an updated broadcast
// mode.
func (ctx Context)

WithBroadcastMode(mode string)

Context {
    ctx.BroadcastMode = mode
	return ctx
}

// WithSignModeStr returns a copy of the context with an updated SignMode
// value.
func (ctx Context)

WithSignModeStr(signModeStr string)

Context {
    ctx.SignModeStr = signModeStr
	return ctx
}

// WithSkipConfirmation returns a copy of the context with an updated SkipConfirm
// value.
func (ctx Context)

WithSkipConfirmation(skip bool)

Context {
    ctx.SkipConfirm = skip
	return ctx
}

// WithTxConfig returns the context with an updated TxConfig
func (ctx Context)

WithTxConfig(generator TxConfig)

Context {
    ctx.TxConfig = generator
	return ctx
}

// WithAccountRetriever returns the context with an updated AccountRetriever
func (ctx Context)

WithAccountRetriever(retriever AccountRetriever)

Context {
    ctx.AccountRetriever = retriever
	return ctx
}

// WithInterfaceRegistry returns the context with an updated InterfaceRegistry
func (ctx Context)

WithInterfaceRegistry(interfaceRegistry codectypes.InterfaceRegistry)

Context {
    ctx.InterfaceRegistry = interfaceRegistry
	return ctx
}

// WithViper returns the context with Viper field. This Viper instance is used to read
// client-side config from the config file.
func (ctx Context)

WithViper(prefix string)

Context {
    v := viper.New()
    if prefix == "" {
    executableName, _ := os.Executable()

prefix = path.Base(executableName)
}

v.SetEnvPrefix(prefix)

v.SetEnvKeyReplacer(strings.NewReplacer(".", "_", "-", "_"))

v.AutomaticEnv()

ctx.Viper = v
	return ctx
}

// WithAux returns a copy of the context with an updated IsAux value.
func (ctx Context)

WithAux(isAux bool)

Context {
    ctx.IsAux = isAux
	return ctx
}

// WithLedgerHasProto returns the context with the provided boolean value, indicating
// whether the target Ledger application can support Protobuf payloads.
func (ctx Context)

WithLedgerHasProtobuf(val bool)

Context {
    ctx.LedgerHasProtobuf = val
	return ctx
}

// WithPreprocessTxHook returns the context with the provided preprocessing hook, which
// enables chains to preprocess the transaction using the builder.
func (ctx Context)

WithPreprocessTxHook(preprocessFn PreprocessTxFn)

Context {
    ctx.PreprocessTxHook = preprocessFn
	return ctx
}

// PrintString prints the raw string to ctx.Output if it's defined, otherwise to os.Stdout
func (ctx Context)

PrintString(str string)

error {
    return ctx.PrintBytes([]byte(str))
}

// PrintBytes prints the raw bytes to ctx.Output if it's defined, otherwise to os.Stdout.
// NOTE: for printing a complex state object, you should use ctx.PrintOutput
func (ctx Context)

PrintBytes(o []byte)

error {
    writer := ctx.Output
    if writer == nil {
    writer = os.Stdout
}

	_, err := writer.Write(o)

return err
}

// PrintProto outputs toPrint to the ctx.Output based on ctx.OutputFormat which is
// either text or json. If text, toPrint will be YAML encoded. Otherwise, toPrint
// will be JSON encoded using ctx.Codec. An error is returned upon failure.
func (ctx Context)

PrintProto(toPrint proto.Message)

error {
	// always serialize JSON initially because proto json can't be directly YAML encoded
	out, err := ctx.Codec.MarshalJSON(toPrint)
    if err != nil {
    return err
}

return ctx.printOutput(out)
}

// PrintObjectLegacy is a variant of PrintProto that doesn't require a proto.Message type
// and uses amino JSON encoding.
// Deprecated: It will be removed in the near future!
func (ctx Context)

PrintObjectLegacy(toPrint any)

error {
    out, err := ctx.LegacyAmino.MarshalJSON(toPrint)
    if err != nil {
    return err
}

return ctx.printOutput(out)
}

// PrintRaw is a variant of PrintProto that doesn't require a proto.Message type
// and uses a raw JSON message. No marshaling is performed.
func (ctx Context)

PrintRaw(toPrint json.RawMessage)

error {
    return ctx.printOutput(toPrint)
}

func (ctx Context)

printOutput(out []byte)

error {
    var err error
    if ctx.OutputFormat == "text" {
    out, err = yaml.JSONToYAML(out)
    if err != nil {
    return err
}
	
}
    writer := ctx.Output
    if writer == nil {
    writer = os.Stdout
}

	_, err = writer.Write(out)
    if err != nil {
    return err
}
    if ctx.OutputFormat != "text" {
		// append new-line for formats besides YAML
		_, err = writer.Write([]byte("\n"))
    if err != nil {
    return err
}
	
}

return nil
}

// GetFromFields returns a from account address, account name and keyring type, given either an address or key name.
// If clientCtx.Simulate is true the keystore is not accessed and a valid address must be provided
// If clientCtx.GenerateOnly is true the keystore is only accessed if a key name is provided
// If from is empty, the default key if specified in the context will be used
func GetFromFields(clientCtx Context, kr keyring.Keyring, from string) (sdk.AccAddress, string, keyring.KeyType, error) {
    if from == "" && clientCtx.KeyringDefaultKeyName != "" {
    from = clientCtx.KeyringDefaultKeyName
		_ = clientCtx.PrintString(fmt.Sprintf("No key name or address provided; using the default key: %s\n", clientCtx.KeyringDefaultKeyName))
}
    if from == "" {
    return nil, "", 0, nil
}

addr, err := sdk.AccAddressFromBech32(from)
    switch {
    case clientCtx.Simulate:
    if err != nil {
    return nil, "", 0, fmt.Errorf("a valid bech32 address must be provided in simulation mode: %w", err)
}

return addr, "", 0, nil
    case clientCtx.GenerateOnly:
    if err == nil {
    return addr, "", 0, nil
}
	
}

var k *keyring.Record
    if err == nil {
    k, err = kr.KeyByAddress(addr)
    if err != nil {
    return nil, "", 0, err
}
	
}

else {
    k, err = kr.Key(from)
    if err != nil {
    return nil, "", 0, err
}
	
}

addr, err = k.GetAddress()
    if err != nil {
    return nil, "", 0, err
}

return addr, k.Name, k.GetType(), nil
}

// NewKeyringFromBackend gets a Keyring object from a backend
func NewKeyringFromBackend(ctx Context, backend string) (keyring.Keyring, error) {
    if ctx.Simulate {
    backend = keyring.BackendMemory
}

return keyring.New(sdk.KeyringServiceName(), backend, ctx.KeyringDir, ctx.Input, ctx.Codec, ctx.KeyringOptions...)
}
```

And that's a wrap! The result of the query is outputted to the console by the CLI.
