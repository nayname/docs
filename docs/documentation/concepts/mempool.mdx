---
title: "App-Side Mempool for EVM Compatibility"
description: "Two-tiered mempool architecture enabling full Ethereum tooling compatibility"
---

## Overview

The app-side mempool is a two-tiered system that queues transactions with nonce gaps locally while broadcasting only executable transactions to the network. This allows Ethereum tooling (Hardhat, Foundry, ethers.js) to submit transaction batches out-of-order without rejection.

### Problem

CometBFT rejects transactions with:
- Nonce gaps (non-sequential nonces)
- Out-of-order batches (common in deployment scripts)

Ethereum tooling expects these transactions to queue rather than fail.

### Design Rationale

The two-tiered approach:
- **Local queue**: Stores gapped transactions without network propagation, preventing invalid transaction gossip
- **Public pool**: Contains only valid transactions, maintaining consensus integrity
- **Automatic promotion**: Moves transactions from local to public when gaps fill, ensuring eventual inclusion

This preserves CometBFT's validation guarantees while providing Ethereum's expected queuing behavior.

### What Gets Queued vs Rejected

**Queued (Local Storage)**:
- **Nonce gaps**: Transactions with nonce > expected nonce
- These are stored locally and promoted when gaps fill

**Rejected (Immediate Failure)**:
- **Insufficient fees**: `GasFeeCap < BaseFee`
- **Insufficient balance**: Transaction cost exceeds account balance
- **Invalid signature**: Malformed or improperly signed transactions
- **Gas limit exceeded**: Transactions exceeding block gas limit

Only nonce-gapped transactions are intercepted and queued. All other validation failures result in immediate rejection with error returned to the client.

## Architecture

The app-side mempool uses a two-tiered system with local and public transaction pools:

```mermaid
flowchart TD
    Submit[Transaction Submission<br/>Client or Peer Node]

    Submit --> Receive

    Receive[CometBFT Receives<br/>Transaction arrives at node]

    Receive --> CheckTx

    CheckTx[CheckTx Validation<br/>App validates transaction]

    CheckTx --> Route{Route<br/>Decision}

    Route -->|Success| AddComet
    Route -->|Nonce Gap| Intercept
    Route -->|Other Error| Discard

    AddComet[Add to Comet Mempool<br/>Executable transactions]

    Intercept[Intercept Error<br/>Return success to client<br/>Add to local queue]

    Discard[Reject<br/>Transaction discarded]

    Intercept --> LocalQueue

    LocalQueue[Local Queue<br/>Non-executable<br/>Nonce gaps]

    LocalQueue --> ValidQueue

    ValidQueue[Valid Queue<br/>Waiting for gaps to fill]

    AddComet --> Broadcast

    Broadcast[P2P Broadcast<br/>Share with network peers]

    AddComet --> BuildBlock
    ValidQueue --> BuildBlock

    BuildBlock[Build Block<br/>ProcessProposal<br/>Sort by fee & nonce]

    ValidQueue -.->|Gap Filled| Promotion

    Promotion[Promotion<br/>Periodic scan<br/>Re-broadcast when ready]

    Promotion --> AddComet

    BuildBlock --> FinalBlock[Final Block<br/>Proposed to network]

    style LocalQueue fill:#ffe0e0
    style ValidQueue fill:#e0ffe0
    style AddComet fill:#e0f0ff
    style Intercept fill:#fff7e6
    style Discard fill:#ffcccc
```

### Core Components

**CheckTx Handler**
Intercepts nonce gap errors during validation, routes gapped transactions to the local queue, and returns success to maintain compatibility with Ethereum tooling that expects queuing behavior. Only nonce gaps are intercepted - other validation failures (insufficient fees, balance, etc.) are rejected immediately.

**TxPool**
Direct port of Ethereum's transaction pool that manages both pending (executable) and queued (future) transactions. Handles promotion, eviction, and replacement according to Ethereum rules.

**LegacyPool**
Stores non-executable transactions with nonce gaps, tracks dependencies between transactions, and automatically promotes them when gaps are filled. The queue contains only transactions waiting for earlier nonces - not transactions with insufficient fees.

**ExperimentalEVMMempool**
Unified structure that manages both EVM and Cosmos transaction pools while providing a single interface for transaction insertion, selection, and removal.

## Transaction Flow

### 1. Transaction Submission
Users or other nodes submit transactions to the chain via JSON-RPC or P2P.

### 2. CometBFT Reception
CometBFT receives the transactions and validates them in the app using CheckTx.

### 3. CheckTx Routing

The CheckTx handler processes transactions with special handling for nonce gaps:

**Success Path** - Immediately executable transactions proceed to the Comet mempool:
```go
// Transaction with correct nonce passes validation
if txNonce == accountNonce {
    // Proceed to Comet mempool for broadcast
    return success
}
```

**Nonce Gap** - Transactions with future nonces are intercepted and queued locally:
```go
if txNonce > accountNonce {
    // Detected nonce gap
    if errors.Is(err, ErrNonceGap) {
        // Route to local queue instead of rejecting
        err := mempool.InsertInvalidNonce(request.Tx)
        // Note: Must intercept error and return success to EVM client
        return interceptedSuccess
    }
}
```

**Other Failures** - Rejected and return error to client:
- **Insufficient fees**: Transactions with `GasFeeCap < BaseFee` fail with `ErrInsufficientFee`
- **Insufficient balance**: Transactions exceeding account balance
- **Invalid signature**: Malformed or invalid transaction signatures

Note: Only nonce gaps trigger local queuing. Fee-related failures result in immediate rejection.

### 4. Comet Mempool Addition
Successfully validated transactions are added to the Comet mempool (FIFO).

### 5. P2P Broadcast
Transactions in the Comet mempool are broadcast to other peers across the network.

### 6. Block Building
When a validator is selected to propose a block, ProcessProposal uses the app-side mempool to build blocks:
- Sorts transactions by account (fee priority) and nonce
- Pulls from both local queue and public pool
- Replaces lower-fee duplicates with higher-fee versions

### 7. Automatic Promotion
The node periodically scans the local queue and promotes transactions when:
- Nonce gaps are filled (either in mempool or from on-chain state)
- Promoted transactions are re-broadcast to the network

## Transaction States

```mermaid
stateDiagram-v2
    [*] --> Submitted: Client submits tx
    Submitted --> CheckTx: Validation

    CheckTx --> Pending: Valid & Executable
    CheckTx --> Queued: Nonce Gap Only
    CheckTx --> Rejected: Invalid (fees, balance, etc.)

    Queued --> Promoted: Gap filled
    Promoted --> Pending: Re-broadcast

    Pending --> Broadcast: P2P propagation
    Pending --> BlockBuilding: Selected for block
    Queued --> BlockBuilding: Direct inclusion

    BlockBuilding --> Committed: In block
    Rejected --> [*]
    Committed --> [*]
```

## API Reference

The txpool namespace provides full Ethereum-compatible RPC methods for querying mempool state. These methods are publicly exposed via the JSON-RPC interface on port 8545:

<AccordionGroup>

<Accordion title="txpool_content">
Returns all pending and queued transactions grouped by account.

**Request**
```json
{
  "jsonrpc": "2.0",
  "method": "txpool_content",
  "params": [],
  "id": 1
}
```

**Response**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "pending": {
      "0x1234...": {
        "100": { /* transaction object */ },
        "101": { /* transaction object */ }
      }
    },
    "queued": {
      "0x5678...": {
        "103": { /* transaction object */ }
      }
    }
  }
}
```

- `pending`: Transactions ready for inclusion in the next block
- `queued`: Valid transactions waiting for nonce gaps to be filled
</Accordion>

<Accordion title="txpool_contentFrom">
Returns transactions for a specific address.

**Request**
```json
{
  "jsonrpc": "2.0",
  "method": "txpool_contentFrom",
  "params": ["0x1234567890abcdef1234567890abcdef12345678"],
  "id": 1
}
```

**Response**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "pending": {
      "100": { /* transaction object */ },
      "101": { /* transaction object */ }
    },
    "queued": {
      "103": { /* transaction object */ }
    }
  }
}
```
</Accordion>

<Accordion title="txpool_inspect">
Returns a human-readable summary of all transactions.

**Request**
```json
{
  "jsonrpc": "2.0",
  "method": "txpool_inspect",
  "params": [],
  "id": 1
}
```

**Response**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "pending": {
      "0x1234...": {
        "100": "0x5678...: 1000 wei + 21000 gas × 20 gwei",
        "101": "contract creation: 0 wei + 100000 gas × 20 gwei"
      }
    },
    "queued": {
      "0x5678...": {
        "103": "0x9abc...: 2000 wei + 21000 gas × 25 gwei"
      }
    }
  }
}
```

**Format**: `<to>: <value> wei + <gas> gas × <gasPrice> wei`
</Accordion>

<Accordion title="txpool_status">
Returns transaction counts for pending and queued pools.

**Request**
```json
{
  "jsonrpc": "2.0",
  "method": "txpool_status",
  "params": [],
  "id": 1
}
```

**Response**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "pending": "0x10",  // 16 pending transactions
    "queued": "0x5"     // 5 queued transactions
  }
}
```
</Accordion>

</AccordionGroup>

## Usage Examples

### Batch Transaction Submission

```javascript
// Ethereum tooling sends multiple transactions
await wallet.sendTransaction({nonce: 100, ...}); // ✓ Immediate execution
await wallet.sendTransaction({nonce: 101, ...}); // ✓ Immediate execution
await wallet.sendTransaction({nonce: 103, ...}); // ✓ Queued locally (gap)
await wallet.sendTransaction({nonce: 102, ...}); // ✓ Fills gap, both execute
```

### Transaction Replacement

```javascript
// Speed up transaction with same nonce, higher fee
const tx1 = await wallet.sendTransaction({
  nonce: 100,
  gasPrice: parseUnits("20", "gwei")
});

// Replace with higher fee
const tx2 = await wallet.sendTransaction({
  nonce: 100, // Same nonce
  gasPrice: parseUnits("30", "gwei") // Higher fee
});
// tx1 is replaced by tx2
```

## Implementation Details

### Configuration

<Note>
For chain developers looking to integrate the app-side mempool into their Cosmos SDK chain, see the [EVM Integration Guide](/docs/documentation/cosmos-sdk/integrate) for complete setup instructions.
</Note>

The mempool is initialized with the following configuration:

```go
type EVMMempoolConfig struct {
    TxPool        *txpool.TxPool
    CosmosPool    sdkmempool.ExtMempool
    AnteHandler   sdk.AnteHandler
    BroadcastTxFn func(txs []*ethtypes.Transaction) error
    BlockGasLimit uint64
}
```

**Key Parameters:**
- **Block Gas Limit**: Maximum gas per block (default: 100,000,000)
- **Queue Size**: Managed by TxPool configuration
- **Eviction Rules**: Time-based and fee-based eviction from Ethereum TxPool

### State Management

The mempool maintains transaction state through the unified `ExperimentalEVMMempool` structure, which manages separate pools for EVM and Cosmos transactions while providing a single interface. This experimental implementation handles fee-based prioritization, nonce sequencing, and transaction verification through an integrated ante handler.

### Testing

The app-side mempool behavior can be verified using the test scripts provided in the [cosmos/evm](https://github.com/cosmos/evm) repository.